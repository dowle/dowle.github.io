<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>mysql锁 - 杜东为的博客</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="dowle"><meta name=description content="锁的简介 锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因"><meta name=keywords content="golang,数据库,系统架构"><meta name=generator content="Hugo 0.75.0 with theme even"><link rel=canonical href=/post/%E6%95%B0%E6%8D%AE%E5%BA%93/20200821mysql%E9%94%81/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.8c3cbcb0324c2bb4875ceccba4007cbad4b4ac8377f33af9953c3e7684534a50.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/even_hide.css><meta property="og:title" content="mysql锁"><meta property="og:description" content="锁的简介 锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因"><meta property="og:type" content="article"><meta property="og:url" content="/post/%E6%95%B0%E6%8D%AE%E5%BA%93/20200821mysql%E9%94%81/"><meta property="article:published_time" content="2020-08-21T15:01:27+08:00"><meta property="article:modified_time" content="2020-08-21T15:01:27+08:00"><meta itemprop=name content="mysql锁"><meta itemprop=description content="锁的简介 锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因"><meta itemprop=datePublished content="2020-08-21T15:01:27+08:00"><meta itemprop=dateModified content="2020-08-21T15:01:27+08:00"><meta itemprop=wordCount content="2653"><meta itemprop=keywords content="数据库,MySQL,锁,"><meta name=twitter:card content="summary"><meta name=twitter:title content="mysql锁"><meta name=twitter:description content="锁的简介 锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Dowle</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>首页</li></a><a href=/post/><li class=mobile-menu-item>归档</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Dowle</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>首页</a></li><li class=menu-item><a class=menu-item-link href=/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>mysql锁</h1><div class=post-meta><span class=post-time>2020-08-21</span><div class=post-category><a href=/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title></h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#锁的简介>锁的简介</a></li><li><a href=#锁的类型>锁的类型</a><ul><li></li></ul></li><li><a href=#myisam锁模式>MYISAM锁模式</a></li><li><a href=#innodb锁模式>INNODB锁模式</a><ul><li></li></ul></li><li><a href=#死锁>死锁</a></li><li><a href=#锁优化的建议>锁优化的建议</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=锁的简介>锁的简介</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是Mysql在服务器层和存储引擎层的的并发控制。<br>加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放等。</p><h2 id=锁的类型>锁的类型</h2><h4 id=按类型划分>按类型划分</h4><ul><li>共享锁（读锁）：其他事务可以读，但不能写。</li><li>排他锁（写锁） ：其他事务不能读取，也不能写。</li><li>意向锁（表锁）: 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），意向共享锁与意向排它锁，这两种意向锁都是表锁</li></ul><h4 id=按粒度划分>按粒度划分</h4><ul><li>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul><h2 id=myisam锁模式>MYISAM锁模式</h2><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。<br>默认情况下，写锁比读锁具有更高的优先级。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。可以通过配置修改优先级。<br>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sql data-lang=sql><span class=k>SHOW</span> <span class=n>STATUS</span> <span class=k>LIKE</span> <span class=s1>&#39;Table%&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><h2 id=innodb锁模式>INNODB锁模式</h2><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><h4 id=innodb加锁方式>INNODB加锁方式</h4><ul><li>意向锁是 InnoDB 自动加的， 不需用户干预。</li><li>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)</li><li>对于普通 SELECT 语句，InnoDB 不会加任何锁。事务可以通过以下语句显式给记录集加共享锁或排他锁：<ol><li>共享锁（S）：SELECT * FROM table_name WHERE &mldr; LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：SELECT * FROM table_name WHERE &mldr; FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ol></li><li>隐式锁定：InnoDB在事务执行过程中，使用两阶段锁协议：随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放</li><li>显式锁定 ：<ol><li>select &mldr; lock in share mode //共享锁</li><li>select &mldr; for update //排他锁</li></ol></li></ul><h4 id=innodb的行锁实现方式>INNODB的行锁实现方式</h4><ul><li>INNODB的行锁是通过索引项上的索引加锁实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁</li><li>无论是主键索引、唯一索引或普通索引，INNODB都会使用行锁来对数据加锁</li><li>分析加锁情况时，需要通过explain分析sql执行计划来观察实际使用的索引</li></ul><h4 id=innodb的间隙锁>INNODB的间隙锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。<br><strong>普通索引的等值查询，也会加间隙锁。防止幻读</strong></p><p>InnoDB使用间隙锁的目的：</p><ol><li>防止幻读，以满足相关隔离级别的要求</li><li>满足恢复和复制的需要</li></ol><h4 id=行锁占用情况查看>行锁占用情况查看</h4><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>show</span> <span class=n>status</span> <span class=k>like</span> <span class=s1>&#39;innodb_row_lock%&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><h2 id=死锁>死锁</h2><ul><li>死锁产生：
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。
当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。
锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li><li>检测死锁：
数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。
死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</li><li>外部锁的死锁检测：
发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</li><li>死锁影响性能：
死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚</li></ul><h2 id=锁优化的建议>锁优化的建议</h2><ol><li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<a href=/tags/mysql/>MySQL</a>
<a href=/tags/%E9%94%81/>锁</a></div><nav class=post-nav><a class=prev href=/post/vcs/20200917mac_git%E5%A4%9Akey%E9%85%8D%E7%BD%AE/><i class="iconfont icon-left"></i><span class="prev-text nav-default">MAC git仓库多key配置</span>
<span class="prev-text nav-mobile"></span></a><a class=next href=/post/php/20200812php%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/><span class="next-text nav-default">PHP的自动加载</span>
<span class="next-text nav-mobile"></span><i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>%!(EXTRA string=<a class=hexo-link href=https://gohugo.io>Hugo</a>)</span>
<span class=division>|</span>
<span class=theme-info>-
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>dowle</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js></script></body></html>